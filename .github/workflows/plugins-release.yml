name: Build and Release Plugins

# 当手动触发时，可以自定义运行名称，方便识别
run-name: ${{ github.event_name == 'workflow_dispatch' && format('Manual Release for {0}', github.event.inputs.plugin_id) || format('Auto Release triggered by {0}', github.triggering_actor) }}

on:
  # 1. 手动触发器
  workflow_dispatch:
    inputs:
      # 让用户选择插件的源目录
      source_directory:
        description: '请选择插件源码所在的根目录'
        required: true
        type: choice
        options:
          - plugins
          - plugins.v2
          - plugins.v3
        default: 'plugins.v2'
      # 手动输入要打包的插件ID
      plugin_id:
        description: '请输入 package.json 中的插件 ID (例如: AutoSignIn)'
        required: true
        type: string
      # 是否为预发布版本
      prerelease:
        description: '是否为预发布版本？'
        required: false
        type: boolean
        default: false

  # 2. 自动触发器：当 main 分支的指定文件发生 push 时
  push:
    branches:
      - main
    paths:
      - 'package*.json'

jobs:
  # 检测需要发布的插件
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.detector.outputs.plugins }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 安装 jq 和 zip
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq zip

      # 检测更新的插件
      - name: Detect updated plugins and generate metadata
        id: detector
        run: |
          PLUGINS_TO_RELEASE="[]"

          add_to_matrix() {
            local PLUGIN_ID="$1"
            local VERSION="$2"
            local SOURCE_DIR="$3"
            local PACKAGE_FILE="$4"
            
            local LOWERCASE_ID=$(echo "$PLUGIN_ID" | tr '[:upper:]' '[:lower:]')
            local PLUGIN_NAME=$(jq -r --arg id "$PLUGIN_ID" '.[$id].name' "$PACKAGE_FILE")
            local RELEASE_NOTES=$(jq -r --arg id "$PLUGIN_ID" --arg ver "v$VERSION" '.[$id].history[$ver]' "$PACKAGE_FILE")
            local TAG_NAME="${LOWERCASE_ID}_${VERSION}"
            local ARCHIVE_BASE_NAME="${PLUGIN_ID}.v${VERSION}"

            local PLUGIN_JSON=$(jq -n \
              --arg id "$PLUGIN_ID" \
              --arg version "$VERSION" \
              --arg name "$PLUGIN_NAME" \
              --arg notes "$RELEASE_NOTES" \
              --arg tag_name "$TAG_NAME" \
              --arg archive_base "$ARCHIVE_BASE_NAME" \
              --arg source_path "${SOURCE_DIR}/${LOWERCASE_ID}" \
              '{id: $id, version: $version, name: $name, notes: $notes, tag_name: $tag_name, archive_base: $archive_base, source_path: $source_path}')
            
            PLUGINS_TO_RELEASE=$(echo "$PLUGINS_TO_RELEASE" | jq --argjson item "$PLUGIN_JSON" '. + [$item]')
          }

          # 手动触发
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "[WorkflowDispatch] 检测单个插件"
            MANUAL_PLUGIN_ID="${{ inputs.plugin_id }}"
            MANUAL_SOURCE_DIR="${{ inputs.source_directory }}"
            
            # 从源目录自动推导 package 文件名
            # 例如: 'plugins.v2' -> '.v2', 'plugins' -> ''
            SUFFIX=${MANUAL_SOURCE_DIR#plugins}
            # 例如: 'package' + '.v2' + '.json' -> 'package.v2.json'
            PACKAGE_FILE_NAME="package${SUFFIX}.json"
            echo "[Info] 自动推断的 Package 文件: ${PACKAGE_FILE_NAME}"

            if [ ! -f "$PACKAGE_FILE_NAME" ]; then 
              echo "[Error] 未找到包装文件: $PACKAGE_FILE_NAME"; 
              exit 1; 
            fi
            VERSION=$(jq -r --arg id "$MANUAL_PLUGIN_ID" '.[$id].version // "null"' "$PACKAGE_FILE_NAME")
            if [ "$VERSION" == "null" ]; then 
              echo "[Error] 插件ID '${MANUAL_PLUGIN_ID}' 未找到。"; 
              exit 1; 
            fi
            IS_RELEASABLE=$(jq -r --arg id "$MANUAL_PLUGIN_ID" '.[$id].release // false' "$PACKAGE_FILE_NAME")
            if [ "$IS_RELEASABLE" != "true" ]; then
              echo "[Error] 插件 '${MANUAL_PLUGIN_ID}' 没有 release 标记 （release 未设置为 true）。"
              exit 1
            fi
            add_to_matrix "$MANUAL_PLUGIN_ID" "$VERSION" "$MANUAL_SOURCE_DIR" "$PACKAGE_FILE_NAME"

          # 自动更新
          elif [ "${{ github.event_name }}" == "push" ]; then
            echo "[Push] 比较版本"
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
            echo "[Info] 检查以下变更的文件:"
            echo "$CHANGED_FILES"

            # 遍历所有已变更的文件
            for FILE in $CHANGED_FILES; do
              # 检查文件名是否符合我们的 package 格式
              if [[ "$FILE" == package*.json ]]; then
                PACKAGE_FILE="$FILE"
                echo "[Info] 检测到相关的 package 文件变更: ${PACKAGE_FILE}"
                
                if ! git show "${{ github.event.before }}:${PACKAGE_FILE}" > old.json 2>/dev/null; then
                  echo "文件 ${PACKAGE_FILE} 在上一个 commit 中不存在，认定为新文件。"
                  echo "{}" > old.json
                fi

                # 从 package 文件名自动推导源目录
                # 例如: 'package.v2.json' -> '.v2.json' -> '.v2'
                TEMP_SUFFIX=${PACKAGE_FILE#package}
                SUFFIX=${TEMP_SUFFIX%.json}

                # 例如: 'plugins' + '.v2' -> 'plugins.v2'
                SOURCE_DIR="plugins${SUFFIX}"
                echo "[Info] 自动推断的源目录: ${SOURCE_DIR}"

                for PLUGIN_ID in $(jq -r 'keys[]' "$PACKAGE_FILE"); do
                  OLD_VERSION=$(jq -r --arg id "$PLUGIN_ID" '.[$id].version // "null"' old.json)
                  NEW_VERSION=$(jq -r --arg id "$PLUGIN_ID" '.[$id].version // "null"' "$PACKAGE_FILE")
                  IS_RELEASABLE=$(jq -r --arg id "$PLUGIN_ID" '.[$id].release // false' "$PACKAGE_FILE")
                  
                  if [ "$OLD_VERSION" != "$NEW_VERSION" ] && [ "$NEW_VERSION" != "null" ] && [ "$IS_RELEASABLE" == "true" ]; then
                    echo "[Info] 发现更新的插件: ${PLUGIN_ID}, 版本: ${OLD_VERSION} -> ${NEW_VERSION}"
                    add_to_matrix "$PLUGIN_ID" "$NEW_VERSION" "$SOURCE_DIR" "$PACKAGE_FILE"
                  fi
                done
              fi
            done
          fi

          echo "--- 要释放的插件（元数据） ---"
          echo "$PLUGINS_TO_RELEASE" | jq .
          echo "plugins=$(echo "$PLUGINS_TO_RELEASE" | jq -c .)" >> $GITHUB_OUTPUT

  # 根据检测结果，构建并发布
  build-and-release:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.matrix != '[]' }}
    name: Release ${{ matrix.plugin.name }} v${{ matrix.plugin.version }} ${{ (github.event_name == 'workflow_dispatch' && inputs.prerelease) && ' (Prerelease)' || '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write

    # 使用 strategy: matrix 来为每个需要发布的插件创建一个并行的任务
    strategy:
      matrix:
        # fromJson 函数会将 Job 1 输出的 JSON 字符串转换回 JSON 对象
        plugin: ${{ fromJson(needs.detect-changes.outputs.matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Package plugin source code
        run: |
          # 检查源码目录是否存在
          if [ ! -d "${{ matrix.plugin.source_path }}" ]; then
            echo "[Error] 未找到源目录: ${{ matrix.plugin.source_path }}"
            exit 1
          fi
          # 打包成 zip 和 tar.gz
          zip -r "${{ matrix.plugin.archive_base }}.zip" "${{ matrix.plugin.source_path }}"
          tar -czvf "${{ matrix.plugin.archive_base }}.tar.gz" "${{ matrix.plugin.source_path }}"
          sha256sum "${{ matrix.plugin.archive_base }}.zip" > "${{ matrix.plugin.archive_base }}.zip.sha256"
          sha256sum "${{ matrix.plugin.archive_base }}.tar.gz" > "${{ matrix.plugin.archive_base }}.tar.gz.sha256"

      # 检查并删除同名的 tag 和 release
      - name: 检查并覆盖已存在的 Release 和 Tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG_NAME="${{ matrix.plugin.tag_name }}"
          echo "[Info] 准备处理标签: $TAG_NAME"

          # 1. 检查并处理 GitHub Release
          # 使用 gh release view 检查是否存在。>/dev/null 2>&1 用于抑制其自身的输出。
          if gh release view "$TAG_NAME" >/dev/null 2>&1; then
            echo "[Warn] 发现已存在的 Release: $TAG_NAME。将被覆盖，正在删除..."
            gh release delete "$TAG_NAME" --yes
          else
            echo "[Info] 未发现已存在的 Release，将直接创建。"
          fi

          # 2. 检查并处理远程 Git Tag
          # `git ls-remote` 会在找到 tag 时返回非空字符串。
          if [ -n "$(git ls-remote --tags origin "$TAG_NAME")" ]; then
            echo "[Warn] 发现已存在的远程 Git Tag: $TAG_NAME。将被覆盖，正在删除..."
            git push origin --delete "$TAG_NAME"
          else
            echo "[Info] 未发现已存在的远程 Git Tag，将直接创建。"
          fi

      # 创建 GitHub Release
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          # Release 的标签名
          tag_name: ${{ matrix.plugin.tag_name }}
          # Release 的标题
          name: ${{ matrix.plugin.name }} ${{ matrix.plugin.version }}
          # Release 的内容
          body: ${{ matrix.plugin.notes }}
          # 将打包好的文件作为附件
          files: |
            ${{ matrix.plugin.archive_base }}.zip
            ${{ matrix.plugin.archive_base }}.tar.gz
            ${{ matrix.plugin.archive_base }}.zip.sha256
            ${{ matrix.plugin.archive_base }}.tar.gz.sha256
          prerelease: ${{ github.event_name == 'workflow_dispatch' && inputs.prerelease || false }}
